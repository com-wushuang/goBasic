### 数组和切片的比较
- 数组的长度是固定的,数组的长度在申明的时候就必须给定，并且之后不会再改变，数组的长度是其类型的一部分，`[1]string`和`[2]string`是两个不同的数组类型
- 切片的长度是可变的,切片在申明时只有元素类型,而没有长度。切片的长度自动地随着其中元素数量的增长而增长，但不会随着元素数量的减少而减小
- 数组是值类型，切片是引用类型

### 长度和容量
切片可以看做是对数组的一层简单的封装，在每个切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。

- 内建函数`len`，得到数组和切片的长度
- 内建函数`cap`，得到数组和切片的容量
- 数组的容量永远等于其长度，都是不可变的
- 切片的容量却不是这样，并且它的变化是有规律的，切片的容量实际上代表了它的底层数组的长度(实际上这并不准确)。

```go

package main

import "fmt"

func main() {
  // 示例1。
  s1 := make([]int, 5)
  fmt.Printf("The length of s1: %d\n", len(s1))
  fmt.Printf("The capacity of s1: %d\n", cap(s1))
  fmt.Printf("The value of s1: %d\n", s1)
  s2 := make([]int, 5, 8)
  fmt.Printf("The length of s2: %d\n", len(s2))
  fmt.Printf("The capacity of s2: %d\n", cap(s2))
  fmt.Printf("The value of s2: %d\n", s2)
}
```
切片s1的容量是5：
用make函数初始化切片时，如果不指明其容量，那么它就会和长度一致。

切片s2的容量是8：
在初始化s2代表的切片时，同时也指定了它的长度和容量。

### 关系本质
数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。

### 切片表达式
数组和切片关系的形象表达：有一个窗口，你可以通过这个窗口看到一个数组，但是不一定能看到该数组中的所有元素，有时候只能看到连续的一部分元素。

当我们用make函数或切片值字面量（比如`[]int{1, 2, 3}`）初始化一个切片时，该窗口最左边的那个小格子总是会对应其底层数组中的第 1 个元素。

```go
s3 := []int{1, 2, 3, 4, 5, 6, 7, 8}
s4 := s3[3:6]
fmt.Printf("The length of s4: %d\n", len(s4))
fmt.Printf("The capacity of s4: %d\n", cap(s4))
fmt.Printf("The value of s4: %d\n", s4)
```
- 我在前面说过，切片的容量代表了它的底层数组的长度，但这仅限于使用make函数或者切片值字面量初始化切片的情况。
- 更通用的规则是：一个切片的容量可以被看作是透过这个窗口最多可以看到的底层数组中元素的个数。
- 由于s4是通过在s3上施加切片操作得来的，所以s3的底层数组就是s4的底层数组。
- 又因为，在底层数组不变的情况下，切片代表的窗口可以向右扩展，直至其底层数组的末尾。
- 所以，s4的容量就是其底层数组的长度8, 减去上述切片表达式中的那个起始索引3，即5。
- 注意，切片代表的窗口是无法向左扩展的。也就是说，我们永远无法透过s4看到s3中最左边的那 3 个元素。

### 切片的底层数组什么时候会被替换？
- 一个切片的底层数组永远不会被替换。为什么？虽然在扩容的时候 Go 语言一定会生成新的底层数组，但是它也同时生成了新的切片。
- 它只是把新的切片作为了新底层数组的窗口，而没有对原切片，及其底层数组做任何改动。
- 在无需扩容时，append函数返回的是指向原底层数组的原切片，而在需要扩容时，append函数返回的是指向新底层数组的新切片。
- 只要新长度不会超过切片的原容量，那么使用append函数对其追加元素的时候就不会引起扩容。这只会使紧邻切片窗口右边的（底层数组中的）元素被新的元素替换掉。
