### 通道是什么？
"不要通过共享内存来通信，而应该通过通信来共享内存"，这是作为 Go 语言的主要创造者之一的 Rob Pike 的至理名言。通道类型恰恰是后半句话的完美实现，我们可以利用通道在多个 goroutine 之间传递数据。

### 通道是并发安全的
通道本身是一种数据类型，也是 Go 语言自带的、唯一一个可以满足并发安全性的类型。

### 通道的初始化
`ch1 := make(chan int, 3)`
- 使用内建函数`make`
- 指定通道内的元素类型，这决定了可以通过这个通道传递什么类型的数据
- 可选的通道容量值，就是指通道最多可以缓存多少个元素值。当容量为0时，我们可以称通道为非缓冲通道。而当容量大于0时，我们可以称为缓冲通道。非缓冲通道和缓冲通道有着不同的数据传递方式。

### 通道的发送和接收
一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到操作符`<-`。
注：关于操作符，只存在`<-`而不存在`->`。表示发送和接收，只需要调整`chan`的位置即可。
```go
package main

import "fmt"

func main() {
	ch1 := make(chan int, 3)
	ch1 <- 2 // 发送 ，chan在左边
	ch1 <- 1
	ch1 <- 3
	elem1 := <-ch1 // 接收，chan在右边
	fmt.Printf("The first element received from channel ch1: %v\n", elem1) //fifo 先入先出
}
```
### 通道的发送和接收操作都有哪些基本的特性？
- 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。 
- 发送操作和接收操作中对元素值的处理都是不可分割的。
- 发送操作在完全完成之前会被阻塞。接收操作也是如此。

第一个特性：
- 在同一时刻，Go 语言的运行时系统（以下简称运行时系统）只会执行对同一个通道的任意个发送操作中的某一个。直到这个元素值被完全复制进该通道之后，其他针对该通道的发送操作才可能被执行。
- 类似的，在同一时刻，运行时系统也只会执行，对同一个通道的任意个接收操作中的某一个。直到这个元素值完全被移出该通道之后，其他针对该通道的接收操作才可能被执行。
- 即使这些操作是并发执行的也是如此,这里所谓的并发执行，你可以这样认为，多个代码块分别在不同的 goroutine 之中，并有机会在同一个时间段内被执行。

第二个特性：
- 元素值从外界进入通道时会被复制。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本。
- 另一方面，元素值从通道进入外界时会被移动。这个移动操作实际上包含了两步，第一步是生成正在通道中的这个元素值的副本，并准备给到接收方，第二步是删除在通道中的这个元素值。
这里的“不可分割”的意思是，它们处理元素值时都是一气呵成的，绝不会被打断。例如，发送操作要么还没复制元素值，要么已经复制完毕，绝不会出现只复制了一部分的情况。又例如，接收操作在准备好元素值的副本之后，一定会删除掉通道中的原值，绝不会出现通道中仍有残留的情况。

第三个特性：
- 发送操作包括了“复制元素值”和“放置副本到通道内部”这两个步骤。
两个步骤完全完成之前，发起这个发送操作的那句代码会一直阻塞在那里。也就是说，在它之后的代码不会有执行的机会，直到这句代码的阻塞解除。运行时系统会通知这句代码所在的 goroutine，以使它去争取继续运行代码的机会。
- 接收操作通常包含了“复制通道内的元素值”“放置副本到接收方”“删掉原值”三个步骤。
在所有这些步骤完全完成之前，发起该操作的代码也会一直阻塞，直到该代码所在的 goroutine 收到了运行时系统的通知并重新获得运行机会为止。

### 发送操作和接收操作在什么时候可能被长时间的阻塞？
缓冲通道：
- 如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。
这时，通道会优先通知最早因此而等待的、那个发送操作所在的 goroutine，后者会再次执行发送操作。
由于发送操作在这种情况下被阻塞后，它们所在的 goroutine 会顺序地进入通道内部的发送等待队列，所以通知的顺序总是公平的。
- 相对的，如果通道已空，那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。
这时，通道会通知最早等待的、那个接收操作所在的 goroutine，并使它再次执行接收操作。
因此而等待的、所有接收操作所在的 goroutine，都会按照先后顺序被放入通道内部的接收等待队列。

```go
    // 示例1。
	ch1 := make(chan int, 1)
	ch1 <- 1
	//ch1 <- 2 // 通道已满，因此这里会造成阻塞。


    // 示例2。
    ch2 := make(chan int, 1)
    //elem, ok := <-ch2 // 通道已空，因此这里会造成阻塞。


    // 示例3。
    var ch3 chan int
    //ch3 <- 1 // 通道的值为nil，因此这里会造成永久的阻塞！
    //<-ch3 // 通道的值为nil，因此这里会造成永久的阻塞！
    _ = ch3
```

非缓冲通道：
- 情况要简单一些。无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。
- 由此可见，非缓冲通道是在用同步的方式传递数据。也就是说，只有收发双方对接上了，数据才会被传递。
- 并且，数据是直接从发送方复制到接收方的，中间并不会用非缓冲通道做中转。

对比：
- 相比之下，缓冲通道则在用异步的方式传递数据。在大多数情况下，缓冲通道会作为收发双方的中间件。 
正如前文所述，元素值会先从发送方复制到缓冲通道，之后再由缓冲通道复制给接收方。
但是，当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方。

nil通道：
以上说的都是在正确使用通道的前提下会发生的事情。下面我特别说明一下，由于错误使用通道而造成的阻塞。对于值为nil的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。它们所属的 goroutine 中的任何代码，都不再会被执行。
注意，由于通道类型是引用类型，所以它的零值就是nil。换句话说，当我们只声明该类型的变量但没有用make函数对它进行初始化时，该变量的值就会是nil。我们一定不要忘记初始化通道！

### 发送操作和接收操作在什么时候会引发 panic？
1.二次关闭一个通道会引发panic
如果我们试图关闭一个已经关闭了的通道，也会引发 panic。注意，接收操作是可以感知到通道的关闭的，并能够安全退出。

2.已关闭的通道，对其进行发送数据
对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发 panic(只会出现阻塞)。但是通道一旦关闭，再对它进行发送操作(接收操作不会)，就会引发 panic。

3.关闭一个nil的通道

### 只读通道和只写通道
`var writeOnlyChan = make(chan<- int)` :只写通道
`var readOnlyChan = make(<-chan int)` :只读通道
单向通道最主要的用途就是约束其他代码的行为。
```go
func SendInt(ch chan<- int) { 
	ch <- rand.Intn(1000)
}
```
```go
intChan1 := make(chan int, 3)
SendInt(intChan1)
```
`SendInt`这个函数只接受一个`chan<- int`类型的参数。在这个函数中的代码只能向参数ch发送元素值，而不能从它那里接收元素值。这就起到了约束函数行为的作用。
在调用SendInt函数的时候，只需要把一个元素类型匹配的双向通道传给它就行了，没必要用单向通道，因为 Go 语言在这种情况下会自动地把双向通道转换为函数所需的单向通道。
```go
// 函数返回一个单向通道
func getIntChan() <-chan int {
	num := 5
	ch := make(chan int, num)
	for i := 0; i < num; i++ {
		ch <- i
	}
	close(ch)
	return ch  //将一个双向通道，转换成了单向通道
}
```
```go
func TestBasic(t *testing.T) {
	intChan2 := getIntChan()
	for elem := range intChan2 {
		fmt.Printf("The element in intChan2: %v\n", elem)
	}
}
```
函数`getIntChan`会返回一个`<-chan int`类型的通道，这就意味着得到该通道的程序，只能从通道中接收元素值。这实际上就是对函数调用方的一种约束了。

### for循环和通道
- 上述for语句会不断地尝试从通道intChan2中取出元素值。即使intChan2已经被关闭了，它也会在取出所有剩余的元素值之后再结束执行。
- 通常，当通道intChan2中没有元素值时，这条for语句会被阻塞在有for关键字的那一行，直到有新的元素值可取。 不过，由于这里的getIntChan函数会事先将intChan2关闭，所以它在取出intChan2中的所有元素值之后会直接结束执行。
- 倘若通道intChan2的值为nil，那么这条for语句就会被永远地阻塞在有for关键字的那一行。

### select和通道
select语句只能与通道联用，它一般由若干个分支组成。每次执行这种语句的时候，一般只有一个分支中的代码会被运行。
- select语句的分支分为两种，一种叫做候选分支，另一种叫做默认分支。
- 候选分支总是以关键字case开头，后跟一个case表达式和一个冒号，然后我们可以从下一行开始写入当分支被选中时需要执行的语句。
- 默认分支其实就是 default case，因为，当且仅当没有候选分支被选中时它才会被执行，所以它以关键字default开头并直接后跟一个冒号。同样的，我们可以在default:的下一行写入要执行的语句。
```go
func example1() {
	// 准备好几个通道。
	intChannels := [3]chan int{
		make(chan int, 1),
		make(chan int, 1),
		make(chan int, 1),
	}
	// 随机选择一个通道，并向它发送元素值。
	index := rand.Intn(3)
	fmt.Printf("The index: %d\n", index)
	intChannels[index] <- index
	// 哪一个通道中有可取的元素值，哪个对应的分支就会被执行。
	select {
	case <-intChannels[0]:
		fmt.Println("The first candidate case is selected.")
	case <-intChannels[1]:
		fmt.Println("The second candidate case is selected.")
	case elem := <-intChannels[2]:
		fmt.Printf("The third candidate case is selected, the element is %d.\n", elem)
	default:
		fmt.Println("No candidate case is selected!")
	}
}
```
- 如果像上述示例那样加入了默认分支，那么无论涉及通道操作的表达式是否有阻塞，select语句都不会被阻塞。如果那几个表达式都阻塞了，或者说都没有满足求值的条件，那么默认分支就会被选中并执行。
- 如果没有加入默认分支，那么一旦所有的case表达式都没有满足求值条件，那么select语句就会被阻塞。直到至少有一个case表达式满足条件为止。
- 我们可能会因为通道关闭了，而直接从通道接收到一个其元素类型的零值。所以，在很多时候，我们需要通过接收表达式的第二个结果值来判断通道是否已经关闭。一旦发现某个通道关闭了，我们就应该及时地屏蔽掉对应的分支或者采取其他措施。这对于程序逻辑和程序性能都是有好处的。
- 如果select语句发现同时有多个候选分支满足选择条件，那么它就会用一种伪随机的算法在这些分支中选择一个并执行。