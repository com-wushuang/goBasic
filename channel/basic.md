### 通道是什么？
"不要通过共享内存来通信，而应该通过通信来共享内存"，这是作为 Go 语言的主要创造者之一的 Rob Pike 的至理名言。通道类型恰恰是后半句话的完美实现，我们可以利用通道在多个 goroutine 之间传递数据。

### 通道是并发安全的
通道本身是一种数据类型，也是 Go 语言自带的、唯一一个可以满足并发安全性的类型。

### 通道的初始化
`ch1 := make(chan int, 3)`
- 使用内建函数`make`
- 指定通道内的元素类型，这决定了可以通过这个通道传递什么类型的数据
- 可选的通道容量值，就是指通道最多可以缓存多少个元素值。当容量为0时，我们可以称通道为非缓冲通道。而当容量大于0时，我们可以称为缓冲通道。非缓冲通道和缓冲通道有着不同的数据传递方式。

### 通道的发送和接收
一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到操作符`<-`。
注：关于操作符，只存在`<-`而不存在`->`。表示发送和接收，只需要调整`chan`的位置即可。
```go
package main

import "fmt"

func main() {
	ch1 := make(chan int, 3)
	ch1 <- 2 // 发送 ，chan在左边
	ch1 <- 1
	ch1 <- 3
	elem1 := <-ch1 // 接收，chan在右边
	fmt.Printf("The first element received from channel ch1: %v\n", elem1) //fifo 先入先出
}
```
### 通道的发送和接收操作都有哪些基本的特性？
- 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。 
- 发送操作和接收操作中对元素值的处理都是不可分割的。
- 发送操作在完全完成之前会被阻塞。接收操作也是如此。

第一个特性：
在同一时刻，Go 语言的运行时系统（以下简称运行时系统）只会执行对同一个通道的任意个发送操作中的某一个。直到这个元素值被完全复制进该通道之后，其他针对该通道的发送操作才可能被执行。
类似的，在同一时刻，运行时系统也只会执行，对同一个通道的任意个接收操作中的某一个。直到这个元素值完全被移出该通道之后，其他针对该通道的接收操作才可能被执行。
即使这些操作是并发执行的也是如此,这里所谓的并发执行，你可以这样认为，多个代码块分别在不同的 goroutine 之中，并有机会在同一个时间段内被执行。
