## 什么是索引?
索引是一种数据结构「平衡树」(非二叉)。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。

## 索引有哪些优缺点？
**索引的优点**
- 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

**索引的缺点**
- 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率。
- 空间方面：索引需要占物理空间。

## 索引的分类
### 按字段特性分类
MySQL索引按字段特性分类可分为:
- 主键索引: 建立在主键上的索引被称为主键索引，一张数据表只能有一个主键索引，索引列值不允许有空值，通常在创建表时一起创建。
- 普通索引: 建立在 `UNIQUE` 字段上的索引被称为唯一索引，一张表可以有多个唯一索引，索引列值允许为空，列值中出现多个空值不会发生重复冲突。
- 前缀索引: 建立在普通字段上的索引被称为普通索引。
- 前缀索引: 对字符类型字段的前几个字符或对二进制类型字段的前几个bytes建立的索引，而不是在整个字段上建索引。前缀索引可以建立在类型为char、varchar、binary、varbinary的列上，可以大大减少索引占用的存储空间，也能提升索引的查询效率。

### 按索引字段个数分类
MySQL索引按字段个数分类可分为:
- 单列索引: 建立在单个列上的索引被称为单列索引。
- 联合索引: 建立在多个列上的索引被称为联合索引，又叫复合索引、组合索引。

### 按物理存储分类
MySQL 索引按叶子节点存储的是否为完整表数据分为:
1. 聚簇索引
2. 二级索引（辅助索引）。

#### 聚簇索引
聚簇索引的每个叶子节点存储了一行完整的表数据，叶子节点间按id列递增连接，可以方便地进行顺序检索。
![cluster_index](https://github.com/com-wushuang/goBasic/blob/main/image/cluster_index.png)
`InnoDB` 表要求必须有聚簇索引，默认在主键字段上建立聚簇索引，在没有主键字段的情况下，表的第一个非空的唯一索引将被建立为聚簇索引，在前两者都没有的情况下，`InnoDB` 将自动生成一个隐式的自增 `id` 列，并在此列上建立聚簇索引。

#### 二级索引
- 二级索引的叶子节点并不存储一行完整的表数据，而是存储了聚簇索引所在列的值。
 ![none_cluster_index](https://github.com/com-wushuang/goBasic/blob/main/image/none_cluster_index.png)
**回表查询**
- 由于二级索引的叶子节点不存储完整的表数据，索引当通过二级索引查询到聚簇索引列值后，还需要回到聚簇索引也就是表数据本身进一步获取数据。
![lookback_index](https://github.com/com-wushuang/goBasic/blob/main/image/lookback_index.png)
- 回表查询 需要额外的 B+tree 搜索过程，必然增大查询耗时。
- 需要注意的是，通过二级索引查询时，回表不是必须的过程，当 `SELECT` 的所有字段在单个二级索引中都能够找到时，就不需要回表，`MySQL` 称此时的二级索引为覆盖索引或触发了索引覆盖。
- 可以用 `Explain` 命令查看SQL语句的执行计划，执行计划的 `Extra` 字段中若出现 `Using index`，表示查询触发了索引覆盖。

## 索引使用场景
**where**
- 上图中，根据id查询记录，因为id字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。
```
增加一个没有建立索引的字段 alter table innodb1 add sex char(1);
按sex检索时可选的索引为null EXPLAIN SELECT*from innodb1 where sex='男';
```
**order by**
- 当我们使用 `order by` 将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。
- 但是如果我们对该字段建立索引 `alter table` 表名 `add index`(字段名)，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。
- 而且如果分页的，那么只用取出索引表某个范围内的索引对应的数据，而不用像上述那取出所有数据进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）

**join**
- 对 `join` 语句匹配关系（on）涉及的字段建立索引能够提高效率

**索引覆盖**
- 如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率。
- 这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。

## 创建索引的原则
索引虽好，但也不是无限制的使用，最好符合一下几个原则
- 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
- 较频繁作为查询条件的字段才去创建索引
- 更新频繁字段不适合创建索引
- 若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)
- 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。
- 定义有外键的数据列一定要建立索引。
- 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
- 对于定义为text、image和bit的数据类型的列不要建立索引。

## 什么是最左匹配原则
- 最左匹配原则都是针对联合索引来说的 。
- 我们都知道索引的底层是一颗B+树，那么联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。
- 例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的:
![left_match_rule](https://github.com/com-wushuang/goBasic/blob/main/image/left_match_rule.png)
- 可以看到 `a` 的值是有顺序的: `1，1，2，2，3，3`，而 `b` 的值是没有顺序的 `1，2，1，4，1，2`。
- 所以 `b = 2` 这种查询条件没有办法利用索引，因为联合索引首先是按 `a` 排序的，`b` 是无序的。
- 同时我们还可以发现在 `a` 值相等的情况下，`b` 值又是按顺序排列的，但是这种顺序是相对的。
- 所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。例如 `a = 1 and b = 2` 时，`a,b`字段都可以使用索引，因为在 `a` 值确定的情况下 `b` 是相对有序的。
- 而 `a>1 and b=2`，`a` 字段可以匹配上索引，但 `b` 值不可以，因为 `a` 的值是一个范围，在这个范围中 `b` 是无序的。

## 不使用索引的原因
有时候在MySQL上执行查询时，即使WHERE条件中涉及的字段已经建立了索引，但MySQL仍然没有使用到该索引，下面针对各种可能的原因进行总结。
- where中的字段涉及隐式数据类型转换
```sql
SELECT * FROM users WHERE a = 1
```
- 建有联合索引，但查询条件不符合最左匹配原则，users表的a、b字段建有联合索引（ab）
```sql
SELECT * FROM users WHERE b = '1'
```
- 字段使用了表达式、函数
```sql
SELECT * FROM users WHERE b + 1 = 2
SELECT * FROM users WHERE FROM_UNIXTIME(b) = 2
```
- 模糊查询时，查询条件第一个字符使用了通配符
```sql
SELECT * FROM users WHERE b LIKE '%tony'
```
- 使用了OR查询
```sql
SELECT * FROM users WHERE a = 1 OR b = 1
```
- 优化器使用错了索引
```
有时候MySQL的优化器会认为有其它的索引更合适，转而使用其它索引来查询的情况，甚至放弃索引使用全表扫描来查询，如果出现这种情况，可以尝试：
1.使用FORCE INDEX关键字来强制MySQL使用正确的索引
2.有可能是索引的统计信息不够准确，导致优化器判断出错，使用ANALYZE TABLE 表名命令来重新统计索引信息
```

## 