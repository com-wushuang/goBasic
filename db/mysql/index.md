## 什么是索引?
索引是一种数据结构「平衡树」(非二叉)。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。

## 索引有哪些优缺点？
**索引的优点**
- 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

**索引的缺点**
- 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率。
- 空间方面：索引需要占物理空间。

## 索引的分类
### 按字段特性分类
MySQL索引按字段特性分类可分为:
- 主键索引: 建立在主键上的索引被称为主键索引，一张数据表只能有一个主键索引，索引列值不允许有空值，通常在创建表时一起创建。
```sql
CREATE TABLE table_name  (
  ....
  PRIMARY KEY (index_column_1) USING BTREE
);
```
- 唯一索引: 建立在 `UNIQUE` 字段上的索引被称为唯一索引，一张表可以有多个唯一索引，索引列值允许为空，列值中出现多个空值不会发生重复冲突。
```sql
CREATE TABLE table_name  (
  ....
  UNIQUE KEY(index_column_1,index_column_2,...) 
);


CREATE UNIQUE INDEX index_name
ON table_name(index_column_1,index_column_2,...); 
```  
- 前缀索引: 建立在普通字段上的索引被称为普通索引。
```sql
CREATE TABLE table_name  (
 ....
  INDEX(index_column_1,index_column_2,...)
 );


CREATE INDEX index_name
ON table_name(index_column_1,index_column_2,...); 
```  
- 前缀索引: 对字符类型字段的前几个字符或对二进制类型字段的前几个bytes建立的索引，而不是在整个字段上建索引。前缀索引可以建立在类型为char、varchar、binary、varbinary的列上，可以大大减少索引占用的存储空间，也能提升索引的查询效率。
```sql
CREATE TABLE table_name(
    column_list,
    INDEX(column_name(length))
);

CREATE INDEX index_name
ON table_name(column_name(length));
```

### 按索引字段个数分类
MySQL索引按字段个数分类可分为:
- 单列索引: 建立在单个列上的索引被称为单列索引。
- 联合索引: 建立在多个列上的索引被称为联合索引，又叫复合索引、组合索引。

### 按物理存储分类
MySQL 索引按叶子节点存储的是否为完整表数据分为:
- 聚簇索引
- 二级索引（辅助索引）。

#### 聚簇索引
聚簇索引的每个叶子节点存储了一行完整的表数据，叶子节点间按 `id` 列递增连接，可以方便地进行顺序检索。
![cluster_index](https://github.com/com-wushuang/goBasic/blob/main/image/cluster_index.png)
`InnoDB` 表要求必须有聚簇索引，默认在主键字段上建立聚簇索引，在没有主键字段的情况下，表的第一个非空的唯一索引将被建立为聚簇索引，在前两者都没有的情况下，`InnoDB` 将自动生成一个隐式的自增 `id` 列，并在此列上建立聚簇索引。

#### 二级索引
- 二级索引的叶子节点并不存储一行完整的表数据，而是存储了聚簇索引所在列的值。
 ![none_cluster_index](https://github.com/com-wushuang/goBasic/blob/main/image/none_cluster_index.png)
**回表查询**
- 由于二级索引的叶子节点不存储完整的表数据，索引当通过二级索引查询到聚簇索引列值后，还需要回到聚簇索引也就是表数据本身进一步获取数据。
![lookback_index](https://github.com/com-wushuang/goBasic/blob/main/image/lookback_index.png)
- 回表查询 需要额外的 B+tree 搜索过程，必然增大查询耗时。
- 需要注意的是，通过二级索引查询时，回表不是必须的过程，当 `SELECT` 的所有字段在单个二级索引中都能够找到时，就不需要回表，`MySQL` 称此时的二级索引为覆盖索引或触发了索引覆盖。
- 可以用 `Explain` 命令查看SQL语句的执行计划，执行计划的 `Extra` 字段中若出现 `Using index`，表示查询触发了索引覆盖。

## 索引使用场景
**where**
- 上图中，根据id查询记录，因为id字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。
```
增加一个没有建立索引的字段 alter table innodb1 add sex char(1);
按sex检索时可选的索引为null EXPLAIN SELECT*from innodb1 where sex='男';
```
**order by**
- 当我们使用 `order by` 将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。
- 但是如果我们对该字段建立索引 `alter table` 表名 `add index`(字段名)，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。
- 而且如果分页的，那么只用取出索引表某个范围内的索引对应的数据，而不用像上述那取出所有数据进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）

**join**
- 对 `join` 语句匹配关系（on）涉及的字段建立索引能够提高效率

**索引覆盖**
- 如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率。
- 这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。

## 创建索引的原则
**什么时候适用索引？**
- 字段有唯一性限制的，比如商品编码。
- 经常用于 `WHERE` 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
- 经常用于 `GROUP BY` 和 `ORDER BY` 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。

**什么时候不需要创建索引？**
- `WHERE` 条件，`GROUP BY`，`ORDER BY` 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。
- 字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。
- 表数据太少的时候，不需要创建索引；
- 经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 `B+Tree` 的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。

## 最左匹配原则
- 最左匹配原则都是针对联合索引来说的 。
- 索引的底层是一颗B+树，联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。
- 例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的:
![left_match_rule](https://github.com/com-wushuang/goBasic/blob/main/image/left_match_rule.png)
- 可以看到 `a` 的值是有顺序的: `1，1，2，2，3，3`，而 `b` 的值是没有顺序的 `1，2，1，4，1，2`。
- 所以 `b = 2` 这种查询条件没有办法利用索引，因为联合索引首先是按 `a` 排序的，`b` 是无序的。
- 同时我们还可以发现在 `a` 值相等的情况下，`b` 值又是按顺序排列的，但是这种顺序是相对的。`b` 是全局无序，局部相对有序的。
- 所以最左匹配原则遇上范围查询就会停止（`>、<、between、like`），剩下的字段都无法使用索引。例如 `a = 1 and b = 2` 时，`a,b`字段都可以使用索引，因为在 `a` 值确定的情况下 `b` 是相对有序的。
- 而 `a>1 and b=2`，`a` 字段可以匹配上索引，但 `b` 值不可以，因为 `a` 的值是一个范围，在这个范围中 `b` 是无序的。 
- 在执行 `select * from table where a > 1 and b = 2` 语句的时候，只有 `a` 字段能用到索引，那在联合索引的 `B+Tree` 找到第一个满足条件的主键值（`ID 为 2`）后，还需要判断其他条件是否满足（`看 b 是否等于 2`），那是在联合索引里判断？还是回主键索引去判断呢？
  - 在 `MySQL 5.6` 之前，只能从 `ID2` （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。
  - 而 `MySQL 5.6` 引入的索引下推优化（`index condition pushdown`)， 可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
  - 当你的查询语句的执行计划里，出现了 `Extra` 为 `Using index condition`，那么说明使用了索引下推的优化。

## 索引失效
有时候在MySQL上执行查询时，即使WHERE条件中涉及的字段已经建立了索引，但MySQL仍然没有使用到该索引，下面针对各种可能的原因进行总结。
- where中的字段涉及隐式数据类型转换
```sql
SELECT * FROM users WHERE a = 1
```
- 建有联合索引，但查询条件不符合最左匹配原则，users表的a、b字段建有联合索引（ab）
```sql
SELECT * FROM users WHERE b = '1'
```
- 字段使用了表达式、函数
```sql
SELECT * FROM users WHERE b + 1 = 2
SELECT * FROM users WHERE FROM_UNIXTIME(b) = 2
```
- 模糊查询时，查询条件第一个字符使用了通配符
```sql
SELECT * FROM users WHERE b LIKE '%tony'
```
- 使用了OR查询
```sql
SELECT * FROM users WHERE a = 1 OR b = 1
```
- 优化器使用错了索引
```
有时候MySQL的优化器会认为有其它的索引更合适，转而使用其它索引来查询的情况，甚至放弃索引使用全表扫描来查询，如果出现这种情况，可以尝试：
1.使用FORCE INDEX关键字来强制MySQL使用正确的索引
2.有可能是索引的统计信息不够准确，导致优化器判断出错，使用ANALYZE TABLE 表名命令来重新统计索引信息
```

## InnoDB 自动创建索引的规则 ?
- 如果有主键，默认会使用主键作为聚簇索引的索引键（key）；
- 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；
- 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）； 
- 其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。

## 为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？
**B+Tree vs B Tree**
- `B+Tree` 只在叶子节点存储数据，而 `B` 树 的非叶子节点也要存储数据，所以 `B+Tree` 的单个节点的数据量更小，在相同的磁盘 `I/O` 次数下，就能查询更多的节点。
- 另外，`B+Tree` 叶子节点采用的是双链表连接，适合 `MySQL` 中常见的基于范围的顺序查找，而 `B` 树无法做到这一点。

**B+Tree vs 二叉树**
- 对于有 `N` 个叶子节点的 `B+Tree`，其搜索复杂度为 `O(logdN)` ，其中 `d` 表示节点允许的最大子节点个数为 `d` 个。
- 在实际的应用当中， `d` 值是大于 `100` 的，这样就保证了，即使数据达到千万级别时，`B+Tree` 的高度依然维持在 `3-4` 层左右，也就是说一次数据查询操作只需要做 `3-4` 次的磁盘 `I/O` 操作就能查询到目标数据。
- 而二叉树的每个父节点的儿子节点个数只能是 `2` 个，意味着其搜索复杂度为 `O(logN)`，这已经比 `B+Tree` 高出不少，因此二叉树检索到目标数据所经历的磁盘 `I/O` 次数要更多。

**B+Tree vs Hash**
- `Hash` 在做等值查询的时候效率贼快，搜索复杂度为 `O(1)`。
- 但是 `Hash` 表不适合做范围查询，它更适合做等值的查询，这也是 `B+Tree` 索引要比 `Hash` 表索引有着更广泛的适用场景的原因。

## 索引优化的方法
这里说一下几种常见优化索引的方法：
- 前缀索引优化；
- 覆盖索引优化；
- 主键索引最好是自增的；
- 防止索引失效；

### 前缀索引优化
- 前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引，那我们为什么需要使用前缀来建立索引呢？
- 使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。
- 不过，前缀索引有一定的局限性，例如：
  - order by 就无法使用前缀索引；
  - 无法把前缀索引用作覆盖索引；

### 覆盖索引优化
- 覆盖索引是指 `SQL` 中 `query` 的所有字段，在索引 `B+Tree` 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。
- 假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？
- 我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。
- 所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。

### 为什么主键最好是自增的？
`InnoDB` 创建主键索引默认为聚簇索引，数据被存放在了 `B+Tree` 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。

如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。

如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。


### 索引最好设置为 NOT NULL
为了更好的利用索引，索引列要设置为 `NOT NULL` 约束，有两个原因：
- 第一个原因：索引列存在 `NULL` 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 `NULL` 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，`count` 会省略值为 `NULL` 的行。
- 第二个原因：`NULL` 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，会导致更多的存储空间占用，因为 `InnoDB` 默认行存储格式 `COMPACT`，会用 `1` 字节空间存储 `NULL` 值列表。