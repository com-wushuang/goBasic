# MySQL 有哪些锁？
## 全局锁
- 要使用全局锁，则要执行这条命：
```sql
flush tables with read lock
```
- 执行后，整个数据库就处于只读状态了，这时其他线程执行以下操作，都会被阻塞：
  - 对数据的增删改操作，比如 `insert、delete、update` 等语句；
  - 对表结构的更改操作，比如 `alter table、drop table` 等语句。
- 如果要释放全局锁，则要执行这条命令：
```sql
unlock tables
```
- 全局锁主要应用于做全库逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

### 全局锁的缺点
- 加上全局锁，意味着整个数据库都是只读状态。那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。
- 那有什么其他方式可以避免？
    - 如果数据库的引擎支持的事务支持可重复读的隔离级别，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。
    - 因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。

## 表级锁
- 表锁；
- 元数据锁（MDL）;
- 意向锁；
- AUTO-INC 锁；

### 表锁
- 如果我们想对学生表（`t_student`）加表锁，可以使用下面的命令：
```
//表级别的共享锁，也就是读锁；
lock tables t_student read;

//表级别的独占锁，也就是写锁；
lock tables t_stuent write;
```
- 需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。
>也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。

- 要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：
```
unlock tables
```
- 另外，当会话退出后，也会释放所有表锁。
- 不过尽量避免在使用 `InnoDB` 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，`InnoDB` 牛逼的地方在于实现了颗粒度更细的行级锁

### 元数据锁
- 我们不需要显示的使用 `MDL`，因为当我们对数据库表进行操作时，会自动给这个表加上 `MDL`：
    - 对一张表进行 `CRUD` 操作时，加的是 `MDL` 读锁；
    - 对一张表做结构变更操作的时候，加的是 `MDL` 写锁；

- 当有线程在执行 `select` 语句（ 加 `MDL` 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 `MDL` 写锁），那么将会被阻塞，直到执行完 `select` 语句（ 释放 `MDL` 读锁）。
- 当有线程对表结构进行变更（ 加 `MDL` 写锁）的期间，如果有其他线程执行了 `CRUD` 操作（ 申请 `MDL` 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 `MDL` 写锁）。

## 行级锁
`InnoDB` 引擎是支持行级锁的，而 `MyISAM` 引擎并不支持行级锁。
- `Record Lock`: 记录锁，也就是仅仅把一条记录锁上；
- `Gap Lock`: 间隙锁，锁定一个范围，但是不包含记录本身；
- `Next-Key Lock`: `Record Lock ` + `Gap Lock` 的组合，锁定一个范围，并且锁定记录本身。
- 普通的 `select` 语句是不会对记录加锁的，如果要在查询时对记录加行锁，可以使用下面这两个方式：
```sql
//对读取的记录加共享锁
select ... lock in share mode;

//对读取的记录加独占锁
select ... for update;
```
- 上面这两条语句必须在一个事务中，因为当事务提交了，锁就会被释放，所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit = 0。