## 什么是事务
事务就是「一组原子性的SQL查询」，或者说一个独立的工作单元。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。
```
1.BEGIN 或 START TRANSACTION 显式地开启一个事务；
2.COMMIT  COMMIT WORK二者是等价的。提交事务，并使已对数据库进行的所有修改成为永久性的；
3.ROLLBACK  ROLLBACK WORK。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；
4.SAVEPOINT identifier 在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；
5.RELEASE SAVEPOINT identifier 删除一个事务的保存点；
6.ROLLBACK TO identifier 把事务回滚到标记点；
7.SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE
```

## 举个例子说说你理解的事务
比较典型的就是银行业务，你有两银行卡，一张是招商银行 `CMBC` 的工资卡，另一张是工商银行 `ICBC` 的储蓄卡，每月 `10` 号发工资都要把招行卡的 `10` 万转到工商银行卡账户。 把转账的操作简化抽成一个事务，包含如下步骤：
- 查询 `CMBC` 账户的余额是否大于10万
- 从 `CMBC` 账户余额中减去10万
- 在 `ICBC` 账户余额中增加10万
```sql
START TRANSACTION;
SELECT balance FROM CMBC WHERE username='you';
UPDATE CMBC SET balance = balance - 100000.00 WHERE username = 'you';
UPDATE ICBC SET balance = balance + 100000.00 WHERE username = 'you';
COMMIT;
```



## 事务有哪些特性？
- `原子性（atomicity)`: 一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作。
- `一致性（consistency)`: 数据库总是从一个一致性的状态转换到另外一个一致性的状态。在前面的例子中，一致性确保了，即使在执行第三、四条语句之间时系统崩溃，`CMBC` 账户中也不会损失10万，不然要哭死，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。
- `隔离性（isolation)`: 通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时如果有其他人准备给你的 `CMBC` 账户存钱，那他看到的 `CMBC` 账户里还是有 `10` 万的。
- `持久性（durability)`: 一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。持久性是个有点模糊的概念，因为实际上持久性也分很多不同的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。而且「不可能有能做到 `100%` 的持久性保证的策略」否则还需要备份做什么

## 什么是脏读、不可重复读、幻读

**脏读**
- 在事务 `A` 修改数据之后提交数据之前，这时另一个事务 `B` 来读取数据，如果不加控制，事务 `B` 读取到 `A` 修改过数据，之后 `A` 又对数据做了修改再提交，则 `B` 读到的数据是脏数据，此过程称为脏读 `Dirty Read`。

|Time|事务A|事务B|
|----|----|----|
|T1|start transaction|start transaction|
|T2| | |
|T3| |查询 CMBC 账户余额10万|
|T4| |买10万理财，余额修改为20万|
|T5| |commit|
|T6|查询 CMBC 余额20万（不可重复读）| |
|T7| | |
|T8|commit| |

**不可重复读**
- 一个事务内在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了变更、或者某些记录已经被删除了。

|Time|事务A|事务B|
|----|----|----|
|T1|start transaction|start transaction|
|T2| | |
|T3| |查询CMBC账户余额10万|
|T4| |买10万理财，余额修改为20万|
|T5| |commit|
|T6|查询CMBC余额20万（不可重复读）| |
|T7| | |
|T8|commit| |

**幻读**
- 事务 `A` 在按查询条件读取某个范围的记录时，事务 `B` 又在该范围内插入了新的满足条件的记录，当事务 `A` 再次按条件查询记录时，会产生新的满足条件的记录（幻行 Phantom Row）

|Time|事务A|事务B|
|----|----|----|
|T1|start transaction|start transaction|
|T2|查询 CMBC 账户，返回两条交易记录| |
|T3| |买10万理财，交易记录加1|
|T4| | |
|T5| |commit|
|T6|查询CMBC交易记录3条（幻读）| |
|T7| | |
|T8|commit| |

**不可重复读与幻读有什么区别？**
- 不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的「数据不一样」。（因为中间有其他事务提交了修改）
- 幻读的重点在于新增或者删除：在同一事务中，同样的条件，第一次和第二次读出来的「记录数不一样」。（因为中间有其他事务提交了插入/删除）

## MySQL事务的四个隔离级别分别是？解决了什么问题
- `SQL` 实现了四个标准的隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。
![mysql_isolation](https://github.com/com-wushuang/goBasic/blob/main/image/mysql_isolation.png)
- 各个隔离级别可以不同程度的解决脏读、不可重复读、幻读。隔离级别各有所长，没有完美的解决方案，要结合具体的业务场景谈具体实施。

## MySQL中哪些存储引擎支持事务？
`MySQL` 中 `InnoDB和NDB Cluster` 存储引擎提供了事务处理能力。

## 什么是自动提交？
`MySQL` 默认采用自动提交 `AUTOCOMMIT` 模式。也就是说，如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作。

## 在事务中可以混合使用存储引擎吗？
- 尽量不要在同一个事务中使用多种存储引擎，`MySQL` 服务器层不管理事务，事务是由下层的存储引擎实现的。
- 如果在事务中混合使用了事务型和非事务型的表（例如 `InnoDB` 和 `MyISAM` 表）,在正常提交的情况下不会有什么问题。
- 但如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定。所以，为每张表选择合适的存储引擎非常重要。

## MySQL存储引擎类型有哪些？
最常用的存储引擎是 `InnoDB引擎` 和 `MyISAM存储引擎`，`InnoDB` 是 `MySQL` 的默认事务引擎。

## InnoDB存储引擎的特点和应用场景？
`InnoDB` 是 `MySQL` 的默认「事务引擎」，被设置用来处理大量短期（`short-lived`）事务，短期事务大部分情况是正常提交的，很少会回滚。

## InnoDB与MyISAM对比
|特性|事务|并发|外键|备份|其他|
|----|----|----|----|----|----|
|InnoDB|事务型|行锁|支持|热备|聚簇索引|
|MyISAM|非事务型|表锁|不支持|不支持|空间数据索引|
- MySQL还支持其他一些存储引擎，比如 `memory` 引擎、`NDB` 集群引擎、`CSV` 引擎，由于这些引擎没有上述 `InnoDB` 和 `MyISAM` 常用，这里不作介绍，感兴趣可以阅读 `MySQL` 文档了解。