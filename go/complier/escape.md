## 什么是逃逸分析 
Go语言的逃逸分析是编译器执行静态代码分析后，对内存管理进行的优化和简化，它可以决定一个变量是分配到堆还栈上。

## 逃逸分析的准则
Go语言逃逸分析最基本的原则是：如果一个函数返回对一个变量的引用，那么它就会发生逃逸：
- 如果函数外部没有引用，则优先放到栈中；
- 如果函数外部存在引用，则必定放到堆中；

## 逃逸场景
- `指针逃逸`:在函数中创建了一个对象，返回了这个对象的指针。这种情况下，函数虽然退出了，但是因为指针的存在，对象的内存不能随着函数结束而回收，因此只能分配在堆上。
- `interface{} 动态类型逃逸`:空接口即 interface{} 可以表示任意的类型，如果函数参数为 interface{}，编译期间很难确定其参数的具体类型，也会发生逃逸。
- `栈空间不足`:对 Go 编译器而言，超过一定大小的局部变量将逃逸到堆上,例如切片。
- `闭包`:
```go
func Increase() func() int {
	n := 0
	return func() int {
		n++
		return n
	}
}

func main() {
	in := Increase()
	fmt.Println(in()) // 1
	fmt.Println(in()) // 2
}
```
`Increase()` 返回值是一个闭包函数，该闭包函数访问了外部变量 `n`，那变量 `n` 将会一直存在，直到 `in` 被销毁。
很显然，变量 `n` 占用的内存不能随着函数 `Increase()` 的退出而回收，因此将会逃逸到堆上。
