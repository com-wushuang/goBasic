### 为什么字典的键类型会受到约束？
- Go 语言的字典类型其实是一个哈希表的特定实现，在这个实现中，键和元素的最大不同在于，键的类型是受限的，而元素却可以是任意类型的。

字典通过键查找值的过程：
- 在哈希表中查找与某个键值对应的那个元素值，那么我们需要先把键值作为参数传给这个哈希表。
- 哈希表会先用哈希函数（hash function）把键值转换为哈希值。
- 一个哈希表会持有一定数量的哈希桶（bucket），这些哈希桶会均匀地储存其所属哈希表收纳的`键 - 元素`对。
- 哈希表会先用这个键哈希值的低几位去定位到一个哈希桶，然后再去这个哈希桶中，查找这个键。
- `键 - 元素`对总是被捆绑在一起存储的，所以一旦找到了键，就一定能找到对应的元素值。随后，哈希表就会把相应的元素值作为结果返回。


字典的键类型不能是哪些类型：
- 函数类型
- 字典类型
- 切片类型

为什么：
- Go 语言一旦定位到了某一个哈希桶，那么就会试图在这个桶中查找键值。具体是怎么找的呢？首先，每个哈希桶都会把自己包含的所有键的哈希值存起来。Go 语言会用被查找键的哈希值与这些哈希值逐个对比，看看是否有相等的。如果一个相等的都没有，那么就说明这个桶中没有要查找的键值，这时 Go 语言就会立刻返回结果了。如果有相等的，那就再用键值本身去对比一次。为什么还要对比？原因是，不同值的哈希值是可能相同的。这有个术语，叫做“哈希碰撞”。所以，即使哈希值一样，键值也不一定一样。如果键类型的值之间无法判断相等，那么此时这个映射的过程就没办法继续下去了。最后，只有键的哈希值和键值都相等，才能说明查找到了匹配的键 - 元素对。
- Go 语言规范规定，键类型的值必须要支持判等操作(==或!=)。由于函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。

运行时panic：
- 如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型，否则在程序运行过程中会引发 panic（即运行时恐慌）
```go

var badMap2 = map[interface{}]int{
  "1":   1,
  []int{2}: 2, // 这里会引发panic。
  3:    3,
}
```
- 这样声明并不会引起什么错误。通过这样的声明躲过了 Go 语言编译器的检查,但是运行时会发生panic。

### 应该优先考虑哪些类型作为字典的键类型？
- 哈希表在映射过程中，“把键值转换为哈希值”以及“把要查找的键值与哈希桶中的键值做对比”， 明显是两个重要且比较耗时的操作。
- 因此，求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。

Go语言类型的哈希算法：
- 对于所有的基本类型、指针类型，以及数组类型、结构体类型和接口类型，Go 语言都有一套算法与之对应。
- 宽度越小的类型速度通常越快。对于布尔类型、整数类型、浮点数类型、复数类型和指针类型来说都是如此。对于字符串类型，由于它的宽度是不定的，所以要看它的值的具体长度，长度越短求哈希越快。
- 类型的宽度是指它的单个值需要占用的字节数。比如，bool、int8和uint8类型的一个值需要占用的字节数都是1，因此这些类型的宽度就都是1。
- 对数组类型的值求哈希实际上是依次求得它的每个元素的哈希值并进行合并，所以速度就取决于它的元素类型以及它的长度。
- 结构体类型的值求哈希实际上就是对它的所有字段值求哈希并进行合并，所以关键在于它的各个字段的类型以及字段的数量。

为什么不建议使用高级数据类型作为字典的键类型：
- 对它们的值求哈希，以及判等的速度较慢。
- 一个数组来说，我可以任意改变其中的元素值，但在变化前后，它却代表了两个不同的键值，结构体类型也是类似。

在那些基本类型中应该优先选择哪一个：
- 数值类型
- 指针类型

### 在值为nil的字典上执行读操作会成功吗，那写操作呢？
由于字典是引用类型所以当我们仅声明而不初始化一个字典类型的变量的时候，它的值会是nil。除了添加`键 - 元素`对，我们在一个值为nil的字典上做任何操作都不会引起错误。当我们试图在一个值为nil的字典中添加`键 - 元素`对的时候，Go 语言的运行时系统就会立即抛出一个 panic。