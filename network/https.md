## 基本过程
![ssl-handshake-steps](https://github.com/com-wushuang/goBasic/blob/main/image/ssl-handshake-steps.png)
- `Client Hello`: 客户端首先会发起 `Client Hello` 阶段的请求，与服务端磋商加密组件。以及客户端生成的随机数，尔后将会用于生成 `session key`。
- `Server Hello`: 服务端收到 `Client Hello` 消息后就马上响应一个 `Server Hello` 给客户端，主要告知客户端所选择加密组件和服务端的随机数。
- `Certificate`: 服务端发送公钥及其签名的操作（不发送签名则无法证明该公钥是所请求服务端所生成），这步操作与 `pre-master secret` 相关。
> 需要注意的是，这个被交换出去的公钥与在 `Certificate` 报文中的证书公钥是两回事，在 `Server Key Exchange` 阶段发送给客户端的公钥是 `DH` 算法的一部分，尔后将会与客户端的另一半公钥生成一个新的共享密钥，用于计算生成 `pre-master secret` 。
- `Server Key Exchange`: 该阶段发送给客户端的公钥是DH算法(密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。)的一部分，尔后将会与客户端的另一半公钥生成一个新的共享密钥，用于计算生成 `pre-master secret`。
- `Server Hello Done`: 最后服务端会发送一个 `Server Hello Done` 消息给客户端，表示 `Server Hello` 消息结束了。
- `Client Key Exchange`: 在确认证书是可信的，并且是属于正要访问的网站之后，客户端将会发送 `DH` 算法中另一半公钥给服务端。此时，根据 `DH` 算法客户端和服务端都可以计算出 `pre-master secret`。用 `pre-master key` 还有客户端和服务端的两个随机数就可以计算出 `session key`。
- `Change Cipher Spec`: 告知对方自己已经准备完毕，可以用磋商后的 `session key` 加密报文并进行传输了。

## DH 密钥交换算法
**例子**

假设甲乙双方需要传递密钥，他们之间可以这么做：
- 甲首选选择一个素数 `p`，例如 `509`，底数 `g`，例如 `5`，随机数 `a`，例如 `123`，然后计算 `A=g^a mod p`，结果是 `215`，然后，甲发送 `p＝509，g=5，A=215` 给乙；
- 乙方收到后，也选择一个随机数 `b`，例如，`456`，然后计算 `B=g^b mod p`，结果是 `181`，乙再同时计算 `s=A^b mod p`，结果是 `121`；
- 乙把计算的 `B=181` 发给甲，甲计算 `s＝B^a mod p` 的余数，计算结果与乙算出的结果一样，都是 `121`。

**总结**
- DH算法解决了密钥在双方不直接传递密钥的情况下完成密钥交换，这个神奇的交换原理完全由数学理论支持。
- 所以最终双方协商出的密钥 `s` 是 `121`。注意到这个密钥 `s` 并没有在网络上传输。而通过网络传输的 `p，g，A 和 B` 是无法推算出 `s` 的，因为实际算法选择的素数是非常大的。
- 如果我们把 `a` 看成甲的私钥，`A` 看成甲的公钥，`b` 看成乙的私钥，`B` 看成乙的公钥，`DH` 算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并根据自己的私钥和对方的公钥，生成最终的密钥 `secretKey`，`DH` 算法通过数学定律保证了双方各自计算出的 `secretKey` 是相同的。
