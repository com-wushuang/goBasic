## 特点
- `TCP` 提供一种面向连接的、可靠的字节流服务
- 在一个 `TCP` 连接中，仅有两方进行彼此通信。广播和多播不能用于 `TCP`
- `TCP` 使用校验和，确认和重传机制来保证可靠传输
- `TCP` 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复
- `TCP` 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制

> 注意：`TCP` 并不能保证数据一定会被对方接收到，因为这是不可能的。`TCP` 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 `TCP` 也不是 `100%` 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。

## TCP 包结构
![tcp_data_struct](https://github.com/com-wushuang/goBasic/blob/main/image/tcp_data_struct.webp)
为了便于理解，忽略选项部分，固定首部通常为 `20` 个字节(图上五行，每行 `8` 个字节)，将按作用分类分析。
- `端口号(port)` : 源端口和目的端口，各16位，端口数`0-65535`
- `序号(seq)`: TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号。长度为 `4` 字节，序号是 `32bit` 的无符号数，序号到达最大值后又从 `0` 开始。
- `确认号(ack)`: 期望收到对方的下一个报文段的数据的第一个字节的序号。确认序号为上次接收的最后一个字节序号加 `1`。只有确认标志位(`ACK`)为 `1` 的时候，确认序号才有效。
- `数据偏移`: 也叫首部长度。占 `4` 个 `bit`，它指出报文段的数据起始处距离 `TCP` 报文段的起始处有多远。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的。
> "首部长度"是 4 位二进制数，单位是32位字，能表示的最大十进制数字是15。 即是15个32位，因此数据偏移的最大值是 15*4=60 个字节，这也是TCP首部的最大字节。因为固定首部的存在，数据偏移的值最小为20个字节，因此选项长度不能超过40字节（减去20个字节的固定首部）。
- `保留(reserve)`: 占6位，保留为今后使用，但目前应置为0。
- `标志位`:
  - 紧急 URG: 当 `URG=1` 时，表明紧急指针字段有效。
  - 确认 ACK: 仅当 `ACK = 1` 时确认号字段才有效，当 `ACK = 0` 时确认号无效。`TCP` 规定，在连接建立后所有的传送的报文段都必须把 `ACK` 置为 `1`。
  - 推送 PSH: 当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，`TCP` 就可以使用推送(`push`)操作。发送方 `TCP` 把 `PSH` 置为 `1` ，并立即创建一个报文段发送出去。接收方 `TCP` 收到 `PSH=1` 的报文段，就尽快地（即"推送"向前）交付接收应用进程。而不用再等到整个缓存都填满了后再向上交付。
  - 复位 RST: 当 `RST=1` 时，表明 `TCP` 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。`RST` 置为 `1` 还用来拒绝一个非法的报文段或拒绝打开一个连接。
  - 同步 SYN: 在连接建立时用来同步序号。当 `SYN=1` 而 `ACK=0` 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 `SYN=1` 和 `ACK=1`。因此 `SYN=1` 就表示这是一个连接请求或连接接受报文。
  - 终止 FIN: 用来释放一个连接。当 `FIN=1` 时，表明此报文段的发送发的数据已发送完毕，并要求释放连接。
- `窗口`: 占2字节。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）,窗口大小是给对方用的。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方一次发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据
> 例如，A发送了一个报文段，其确认号是3000，窗口字段是1000.这就是告诉对方B：“从3000算起，A接收缓存空间还可接受1000个字节数据，字节序号是3000-3999”，可以想象到河道的阀门。总之：窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化。
- `检验和`: 占2字节。检验和字段检验的范围包括首部和数据这两部分。和 `UDP` 用户数据报一样，在计算检验和时，要在 `TCP` 报文段的前面加上 `12字节` 的伪首部。伪首部的格式和 `UDP` 用户数据报的伪首部一样。但应把伪首部第 `4` 个字段中的 `17` 改为 `6`（TCP的协议号是6）；把第5字段中的 `UDP` 中的长度改为 `TCP` 长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用TPv6,则相应的伪首部也要改变。
- `紧急指针`: 占2字节。紧急指针仅在 `URG=1` 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据） 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，`TCP` 就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为 `0` 时也可以发送紧急数据。
- `选项`: 长度可变，最长可达 `40` 个字节。当没有使用"选项"时，`TCP` 的首部长度是 `20` 字节。

### 序列号的作用
- 序列号的作用是使得一个 `TCP` 接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。
- 因为 `TCP` 使用 `IP` 来传输报文段，而IP不提供重复消除或者保证次序正确的功能。
- 另一方面，`TCP` 是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。
- 因此 `TCP` 接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满(等待数据填充完毕)。
- 不难想象，接收端的数据 `buffer` 会根据序列号排序将数据填充完毕后再交给上层程序。

### 初始序号 ISN
- 当新连接建立的时候，第一个字节数据的序号称为 `ISN(Initial Sequence Number)`，即初始序号。
- `ISN` 一开始并不一定就是 `1`。
- 在 `RFC` 中规定，`ISN` 的分配是根据时间来的。当操作系统初始化的时候，有一个全局变量假设为 `g_number` 被初始化为 `1`(或 `0`)，然后每隔 `4us` 加 `1`。 当 `g_number` 达到最大值的时候又绕回到 `0` 。当新连接建立时，就把 `g_number` 的值赋值给 `ISN`。
- 在 `BSD` 系统中，这段代码实现时并未遵守协议，它将 `g_number` 初始化为 `1`，每 `8us` 加 `1`，也就是说，每隔 `1` 秒增加 `125000`，约 `9.5` 小时后 `g_number` 又绕回到了 `0`。
- 初始序号是非常非常重要的概念，它告诉对端，第一个报文段是谁！而三次握手的目的，就是为了确认初始序号。

### 确认号的作用
- 如果你还记得前面你和你对象发短信的例子的话，这里就不难了。每传送一个 `TCP` 段，都要等待对方回复一个确认。不过这种方式效率太低，在 `TCP` 协议中，一般采用累积确认的方式，即每传送多个连续 `TCP` 段，可以只对最后一个 `TCP` 段进行确认。
- 对方通过回复一个确认号，来表示确认已经接收到了哪个 `TCP` 段。比如发送方发送了一个报文段序号为 `301` 的 `TCP` 段，这个段携带了 `100` 字节数据，则接收方应当回复的确认号是 `401`，它表示接收方已经收到了字节序号为 `[0, 400]` 的数据，现在期望你发送字节序号为 `401` 以及以后的数据。
>只有当 ACK 标志位被置位的时候，确认号这个字段才有效

## TCP连接
所谓的"连接"，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。

### 三次握手建立连接
![Three_way_Handshake](https://github.com/com-wushuang/goBasic/blob/main/image/Three_way_Handshake.webp)
所谓三次握手(`Three-way Handshake`)，是指建立一个 `TCP` 连接时，需要客户端和服务器总共发送 `3` 个包。 三次握手的目的是连接服务器指定端口，建立 `TCP` 连接，并同步连接双方的序列号和确认号，交换 `TCP` 窗口大小信息。在 `socket` 编程中，客户端执行 `connect()` 时。将触发三次握手。
- 首先，服务端和客户端都是处于`CLOSED`状态的，然后服务端启动，监听端口，状态变为`LISTEN(监听)`状态。
- 第一次握手(`SYN=1, seq=x`): 客户端发送一个 `TCP` 的 `SYN` 标志位置 `1` 的包，指明客户端打算连接的服务器的端口，以及初始序号`ISN(假设为x)`，保存在序列号`seq`)字段里。 发送完毕后，客户端进入 `SYN_SEND(同步已发送)` 状态。(TCP规定：`SYN=1` 的报文段不能携带数据，但是要消耗掉一个序号: `seq=x`)
- 第二次握手(`SYN=1, ACK=1, seq=y, ACKnum=x+1`): 服务器发回确认包(`ACK`)应答。 `SYN` 标志位和 `ACK` 标志位均为 `1`。服务器端选择自己初始序号`ISN(假设为y)` 序列号，放到 `seq` 字段里。同时将确认号 `ACKnum` 设置为客户端的 `ISN` 加 `1`，即 `x+1`。 发送完毕后，服务器端进入 `SYN_RCVD(同步已接受)` 状态。
- 第三次握手(`ACK=1, seq=x+1, ACKnum=y+1`): 客户端再次发送确认包(`ACK`)。`SYN` 标志位为 `0` ，`ACK` 标志位为 `1` 。序列号设置为`seq=x+1`。并且把服务器发来 `seq` 序号字段 `+1`，即`y+1`，放在确定字段中发送给对方。发送完毕后，客户端进入 `ESTABLISHED(已连接)` 状态，当服务器端接收到这个包时，也进入 `ESTABLISHED(已连接)` 状态，TCP 握手结束。

### 为什么需要三次握手？
**确认双方的收发能力**
- 客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。
- 第一次握手（客户端发送 SYN 报文给服务器，服务器接收该报文）：
  - 客户端什么都不能确认；
  - 服务器确认了对方发送正常，自己接收正常
- 第二次握手（服务器响应 SYN 报文给客户端，客户端接收该报文）：
  - 客户端确认了：自己发送、接收正常，对方发送、接收正常；
  - 服务器确认了：对方发送正常，自己接收正常
- 第三次握手（客户端发送 ACK 报文给服务器）：
  - 客户端确认了：自己发送、接收正常，对方发送、接收正常；
  - 服务器确认了：自己发送、接收正常，对方发送、接收正常
  
**阻止重复历史连接的初始化**
- "已失效的连接请求报文段"的产生在这样一种情况下：`client` 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，客户端重发了建立链接的请求并成功通信，连接释放，这之后最开始的建立链接的请求到达 `server` 。
- 本来这是一个早已失效的报文段。但 `server` 收到此失效的连接请求报文段后，就误认为是 `client` 再次发出的一个新的连接请求。于是就向 `client` 发出确认报文段，同意建立连接。
- 假设不采用"三次握手"，那么只要 `server` 发出确认，新的连接就建立了。由于现在 `client` 并没有发出建立连接的请求，因此不会理睬 `server` 的确认，也不会向 `server` 发送数据。
- 但 `server` 却以为新的运输连接已经建立，并一直等待 `client` 发来数据。
- 这样，`server` 的很多资源就白白浪费掉了。采用"三次握手"的办法可以防止上述现象发生。
- 例如刚才那种情况，`client` 不会向 `server` 的确认发出确认。`server` 由于收不到确认，就知道 `client` 并没有要求建立连接。

**序列号可靠同步**
- 如果是两次握手，服务端无法确定客户端是否已经接收到了自己发送的初始序列号
- 如果第二次握手报文丢失，那么客户端就无法知道服务端的初始序列号，那 TCP 的可靠性就无从谈起。

### 四次挥手断开连接
终止一个 TCP 连接要经过四次挥手。这是由于 `TCP` 的半关闭（`half-close`）特性造成的，`TCP` 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。
![tcp_close_connect](https://github.com/com-wushuang/goBasic/blob/main/image/tcp_close_connect.webp)
- `第一次挥手`：客户端发送一个 `FIN` 报文（请求连接终止：`FIN = 1`），报文中会指定一个序列号 `seq = u`。并停止再发送数据，主动关闭 `TCP` 连接。此时客户端处于 `FIN_WAIT1` 状态，等待服务端的确认。
- `第二次挥手`：
  - 服务端收到 `FIN` 之后，会发送 `ACK` 报文，且把客户端的序号值 `+1` 作为 `ACK` 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。
  - 此时的 `TCP` 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入 `FIN_WAIT2` 状态，等待服务端发出的连接释放报文段。
- `第三次挥手`：如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 `FIN` 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态，等待客户端的确认。
- `第四次挥手`：客户端收到 `FIN` 之后，一样发送一个 `ACK` 报文作为应答（`ack = w+1`），且把服务端的序列值 `+1` 作为自己 `ACK` 报文的序号值（`seq=u+1`），此时客户端处于 `TIME_WAIT` （时间等待）状态。
> 这个时候由服务端到客户端的 TCP 连接并未释放掉，需要经过时间等待计时器设置的时间 2MSL（一个报文的来回时间） 后才会进入 CLOSED 状态（这样做的目的是确保服务端收到自己的 ACK 报文。如果服务端在规定时间内没有收到客户端发来的 ACK 报文的话，服务端会重新发送 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文给服务端）。服务端收到 ACK 报文之后，就关闭连接了，处于 CLOSED 状态。

### 为什么需要四次挥手？
**原因一**
- 由于 `TCP` 的半关闭（`half-close`）特性，`TCP` 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。
- 任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。
- 通俗的来说，两次握手就可以释放一端到另一端的 `TCP` 连接，完全释放连接一共需要四次握手。
> 举个例子：A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。

**原因二**
- 其实在 `TCP` 握手的时候，接收端发送 `SYN+ACK` 的包是将一个 `ACK` 和一个 `SYN` 合并到一个包中，所以减少了一次包的发送，三次完成握手。
- 对于四次挥手，因为 `TCP` 是全双工通信，在主动关闭方发送 `FIN` 包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的 `FIN` 包与对客户端的 `ACK` 包合并发送，只能先确认 `ACK`，然后服务器待无需发送数据时再发送 `FIN` 包，所以四次挥手时必须是四次数据包的交互。

## TCP长连接和短连接
