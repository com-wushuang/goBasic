## 特点
- `TCP` 提供一种面向连接的、可靠的字节流服务
- 在一个 `TCP` 连接中，仅有两方进行彼此通信。广播和多播不能用于 `TCP`
- `TCP` 使用校验和，确认和重传机制来保证可靠传输
- `TCP` 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复
- `TCP` 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制

> 注意：`TCP` 并不能保证数据一定会被对方接收到，因为这是不可能的。`TCP` 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 `TCP` 也不是 `100%` 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。

## TCP 包结构
![tcp_data_struct](https://github.com/com-wushuang/goBasic/blob/main/image/tcp_data_struct.webp)
为了便于理解，忽略选项部分，固定首部通常为 `20` 个字节(图上五行，每行 `8` 个字节)，将按作用分类分析。
- `端口号(port)` : 源端口和目的端口，各16位，端口数`0-65535`
- `序号(seq)`: TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号。长度为 `4` 字节，序号是 `32bit` 的无符号数，序号到达最大值后又从 `0` 开始。
- `确认号(ack)`: 期望收到对方的下一个报文段的数据的第一个字节的序号。确认序号为上次接收的最后一个字节序号加 `1`。只有确认标志位(`ACK`)为 `1` 的时候，确认序号才有效。
- `数据偏移`: 也叫首部长度。占 `4` 个 `bit`，它指出报文段的数据起始处距离 `TCP` 报文段的起始处有多远。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的。
> "首部长度"是 4 位二进制数，单位是32位字，能表示的最大十进制数字是15。 即是15个32位，因此数据偏移的最大值是 15*4=60 个字节，这也是TCP首部的最大字节。因为固定首部的存在，数据偏移的值最小为20个字节，因此选项长度不能超过40字节（减去20个字节的固定首部）。
- `保留(reserve)`: 占6位，保留为今后使用，但目前应置为0。
- `标志位`:
  - 紧急 URG: 当 `URG=1` 时，表明紧急指针字段有效。
  - 确认 ACK: 仅当 `ACK = 1` 时确认号字段才有效，当 `ACK = 0` 时确认号无效。`TCP` 规定，在连接建立后所有的传送的报文段都必须把 `ACK` 置为 `1`。
  - 推送 PSH: 当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，`TCP` 就可以使用推送(`push`)操作。发送方 `TCP` 把 `PSH` 置为 `1` ，并立即创建一个报文段发送出去。接收方 `TCP` 收到 `PSH=1` 的报文段，就尽快地（即"推送"向前）交付接收应用进程。而不用再等到整个缓存都填满了后再向上交付。
  - 复位 RST: 当 `RST=1` 时，表明 `TCP` 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。`RST` 置为 `1` 还用来拒绝一个非法的报文段或拒绝打开一个连接。
  - 同步 SYN: 在连接建立时用来同步序号。当 `SYN=1` 而 `ACK=0` 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 `SYN=1` 和 `ACK=1`。因此 `SYN=1` 就表示这是一个连接请求或连接接受报文。
  - 终止 FIN: 用来释放一个连接。当 `FIN=1` 时，表明此报文段的发送发的数据已发送完毕，并要求释放连接。
- `窗口`: 占2字节。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）,窗口大小是给对方用的。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方一次发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据
> 例如，A发送了一个报文段，其确认号是3000，窗口字段是1000.这就是告诉对方B：“从3000算起，A接收缓存空间还可接受1000个字节数据，字节序号是3000-3999”，可以想象到河道的阀门。总之：窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化。
- `检验和`: 占2字节。检验和字段检验的范围包括首部和数据这两部分。和 `UDP` 用户数据报一样，在计算检验和时，要在 `TCP` 报文段的前面加上 `12字节` 的伪首部。伪首部的格式和 `UDP` 用户数据报的伪首部一样。但应把伪首部第 `4` 个字段中的 `17` 改为 `6`（TCP的协议号是6）；把第5字段中的 `UDP` 中的长度改为 `TCP` 长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用TPv6,则相应的伪首部也要改变。
- `紧急指针`: 占2字节。紧急指针仅在 `URG=1` 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据） 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，`TCP` 就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为 `0` 时也可以发送紧急数据。
- `选项`: 长度可变，最长可达 `40` 个字节。当没有使用"选项"时，`TCP` 的首部长度是 `20` 字节。

### 序列号的作用
- 序列号的作用是使得一个 `TCP` 接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。
- 因为 `TCP` 使用 `IP` 来传输报文段，而IP不提供重复消除或者保证次序正确的功能。
- 另一方面，`TCP` 是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。
- 因此 `TCP` 接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满(等待数据填充完毕)。
- 不难想象，接收端的数据 `buffer` 会根据序列号排序将数据填充完毕后再交给上层程序。

### 初始序号 ISN
- 当新连接建立的时候，第一个字节数据的序号称为 `ISN(Initial Sequence Number)`，即初始序号。
- `ISN` 一开始并不一定就是 `1`。
- 在 `RFC` 中规定，`ISN` 的分配是根据时间来的。当操作系统初始化的时候，有一个全局变量假设为 `g_number` 被初始化为 `1`(或 `0`)，然后每隔 `4us` 加 `1`。 当 `g_number` 达到最大值的时候又绕回到 `0` 。当新连接建立时，就把 `g_number` 的值赋值给 `ISN`。
- 在 `BSD` 系统中，这段代码实现时并未遵守协议，它将 `g_number` 初始化为 `1`，每 `8us` 加 `1`，也就是说，每隔 `1` 秒增加 `125000`，约 `9.5` 小时后 `g_number` 又绕回到了 `0`。
- 初始序号是非常非常重要的概念，它告诉对端，第一个报文段是谁！而三次握手的目的，就是为了确认初始序号。

### 确认号的作用
- 如果你还记得前面你和你对象发短信的例子的话，这里就不难了。每传送一个 `TCP` 段，都要等待对方回复一个确认。不过这种方式效率太低，在 `TCP` 协议中，一般采用累积确认的方式，即每传送多个连续 `TCP` 段，可以只对最后一个 `TCP` 段进行确认。
- 对方通过回复一个确认号，来表示确认已经接收到了哪个 `TCP` 段。比如发送方发送了一个报文段序号为 `301` 的 `TCP` 段，这个段携带了 `100` 字节数据，则接收方应当回复的确认号是 `401`，它表示接收方已经收到了字节序号为 `[0, 400]` 的数据，现在期望你发送字节序号为 `401` 以及以后的数据。
>只有当 ACK 标志位被置位的时候，确认号这个字段才有效

## TCP连接
所谓的"连接"，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。

### TCP服务模型
- 一个 `TCP` 连接由一个 `4元组` 构成，分别是两个`IP地址`和两个`端口号`。
- 一个 `TCP` 连接通常分为三个阶段：启动、数据传输、退出（关闭）。
- 当 `TCP` 接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。`ACK` 是累积的，一个确认字节号 `N` 的 `ACK` 表示所有直到 `N` 的字节（不包括 `N` ）已经成功被接收了。这样的好处是如果一个 `ACK` 丢失，很可能后续的 `ACK` 就足以确认前面的报文段了。
- 一个完整的 `TCP` 连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个 `TCP` 报文段都包含了相反方向上的报文段的一个 `ACK`。
- 序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。

### 三次握手建立连接
![Three_way_Handshake](https://github.com/com-wushuang/goBasic/blob/main/image/Three_way_Handshake.webp)
所谓三次握手(`Three-way Handshake`)，是指建立一个 `TCP` 连接时，需要客户端和服务器总共发送 `3` 个包。 三次握手的目的是连接服务器指定端口，建立 `TCP` 连接，并同步连接双方的序列号和确认号，交换 `TCP` 窗口大小信息。在 `socket` 编程中，客户端执行 `connect()` 时。将触发三次握手。
- 首先，服务端和客户端都是处于`CLOSED`状态的，然后服务端启动，监听端口，状态变为`LISTEN(监听)`状态。
- 第一次握手(`SYN=1, seq=x`): 客户端发送一个 `TCP` 的 `SYN` 标志位置 `1` 的包，指明客户端打算连接的服务器的端口，以及初始序号`ISN(假设为x)`，保存在序列号`seq`)字段里。 发送完毕后，客户端进入 `SYN_SEND(同步已发送)` 状态。(TCP规定：`SYN=1` 的报文段不能携带数据，但是要消耗掉一个序号: `seq=x`)
- 第二次握手(`SYN=1, ACK=1, seq=y, ACKnum=x+1`): 服务器发回确认包(`ACK`)应答。 `SYN` 标志位和 `ACK` 标志位均为 `1`。服务器端选择自己初始序号`ISN(假设为y)` 序列号，放到 `seq` 字段里。同时将确认号 `ACKnum` 设置为客户端的 `ISN` 加 `1`，即 `x+1`。 发送完毕后，服务器端进入 `SYN_RCVD(同步已接受)` 状态。
- 第三次握手(`ACK=1, seq=x+1, ACKnum=y+1`): 客户端再次发送确认包(`ACK`)。`SYN` 标志位为 `0` ，`ACK` 标志位为 `1` 。序列号设置为`seq=x+1`。并且把服务器发来 `seq` 序号字段 `+1`，即`y+1`，放在确定字段中发送给对方。发送完毕后，客户端进入 `ESTABLISHED(已连接)` 状态，当服务器端接收到这个包时，也进入 `ESTABLISHED(已连接)` 状态，TCP 握手结束。

### 为什么需要三次握手？
**原因一**

- 客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。
- `第一次握手`：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
- `第二次握手`：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。
- `第三次握手`：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。

**原因二**

- "已失效的连接请求报文段"的产生在这样一种情况下：`client` 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，客户端重发了建立链接的请求并成功通信，连接释放，这之后最开始的建立链接的请求到达 `server` 。
- 本来这是一个早已失效的报文段。但 `server` 收到此失效的连接请求报文段后，就误认为是 `client` 再次发出的一个新的连接请求。于是就向 `client` 发出确认报文段，同意建立连接。
- 假设不采用"三次握手"，那么只要 `server` 发出确认，新的连接就建立了。由于现在 `client` 并没有发出建立连接的请求，因此不会理睬 `server` 的确认，也不会向 `server` 发送数据。
- 但 `server` 却以为新的运输连接已经建立，并一直等待 `client` 发来数据。
- 这样，`server` 的很多资源就白白浪费掉了。采用"三次握手"的办法可以防止上述现象发生。
- 例如刚才那种情况，`client` 不会向 `server` 的确认发出确认。`server` 由于收不到确认，就知道 `client` 并没有要求建立连接。